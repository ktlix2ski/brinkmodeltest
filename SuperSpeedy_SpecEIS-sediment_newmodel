import os    
os.environ["OMP_NUM_THREADS"] = '1' 
import matplotlib
import firedrake as df
import matplotlib
# matplotlib.use('TkAgg')     #uncoment for active plotting, does not work when remote 
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import FuncAnimation
import numpy as np
import ufl
import signal
from datetime import datetime
import json
from firedrake import *
import sys
import pickle
import gzip

# HELPER FUNCTIONS
def Max(a, b): return (a+b+abs(a-b))/df.Constant(2)

def Min(a, b): return (a+b-abs(a-b))/df.Constant(2)

def softplus(y1,y2,alpha=1):
    # The softplus function is a differentiable approximation
    # to the ramp function.  Its derivative is the logistic function.
    # Larger alpha makes a sharper transition.
    return Max(y1,y2) + (1./alpha)*df.ln(1+df.exp(alpha*(Min(y1,y2)-Max(y1,y2))))

from numpy.polynomial.legendre import leggauss
def full_quad(order):
    # This function provides the points and weights for
    # Gaussian quadrature (here used in the vertical dimension)
    points,weights = leggauss(order)
    points = (points+1)/2.
    weights /= 2.
    return points,weights

# Logistic function
sigmoid = lambda z: 1./(1+df.exp(-z))

#L = 45000.                  # OG: Characteristic domain length
L = 55000                    #KT: Leconte L
spy = 60**2*24*365          
thklim = 1.0                # Minimum Ice Thickness

zmin = -300.0               # Minimum elevation
zmax = 2200.0               # Maximum elevation from OG

amin = df.Constant(-16.0)       # Minimum smb
amax = df.Constant(8)        # Maximum smb

c = 2.0                       # Coefficient of exponential decay

amp = 100                   # Amplitude of sinusoidal topography 

rho = rho_i = 917.                  # Ice density
rho_w = 1029.0              # Seawater density
rho_s = 1600.0              # Sediment density
rho_r = 2650.0              # Bedrock density

La = 3.35e5                 #KT: latent heat of melting?

g = 9.81                       # Gravitational acceleration
n = 3.0                        # Glen's exponent
m = 1.0                        # Sliding law exponent
b = 1e-16**(-1./n)             # Ice hardness
eps_reg = df.Constant(1e-4)    # Regularization parameter


l_s = df.Constant(2.0)         # Sediment thickness at which bedrock erosion becomes negligible 
be = df.Constant(2e-9)         # Bedrock erosion coefficient
#be = df.Constant(1e-8)         # Paper code Bedrock erosion coefficient
cc = df.Constant(3.5e-11)        # Fluvial erosion coefficient
#cc = df.Constant(2e-12)        # Paper code Fluvial erosion coefficient
d = df.Constant(500.0)         # Fallout fraction
h_0 = df.Constant(0.1)         # Subglacial cavity depth  

k = df.Constant(0.7)           # Fraction of overburden defining water pressure

# Shelf collapse factor 
# units of a^{-1}
scf = df.Constant(0.2)          # Fraction of floating ice removed per year

# k_diff = df.Constant(20)       # Sediment diffusivity
k_diff = df.Constant(20)       
h_ref = df.Constant(10)        # Thickness at which diffusivity stops increasing: sediment diffusive fluxes need to go
                               # to zero as sediment thickness goes to zero, which implies that the flux should be 
                               # proportional to the sed thickness - however, we also don't want thicker moraines to
                               # diffuse faster than thin ones, because we don't think that's how hillslope processes
                               # work.  As such the sediment flux is proportional to 1 - e^-(h/h_ref), which approximates
                               # a thickness-linear flux for thin sediment and thickness-independent flux for thick sediment.  

dt_float = 0.1                  # OG Time step

dt = df.Constant(dt_float)

##########################################################
################           MESH          #################
##########################################################  

# Define a rectangular mesh
nx = 300
mesh = df.IntervalMesh(nx,0,2*L)       #OG uses length of domain as 2*L

Q_dg = df.FunctionSpace(mesh,"DG",0)
H = df.Function(Q_dg)

x, = df.SpatialCoordinate(mesh)

surface_expression = (zmax - zmin)*df.exp(-3*x/L)  + zmin - amp*df.sin(4*np.pi*x/L) + thklim
bed_expression = (zmax - zmin)*df.exp(-3*x/L)  + zmin - amp*df.sin(4*np.pi*x/L)
#bed_expression = (zmax - zmin)*df.exp(-2.5*x/L)  + zmin - amp*df.sin(4*np.pi*x/40000)  #KT: trying other bed expressions
beta_expression = df.Constant(50.0)         #KT interp: basal friction coefficient?

#########################################################
#################  FUNCTION SPACES  #####################
#########################################################

nhat = df.FacetNormal(mesh)[0]

# CG1 Function Space
E_cg = df.FiniteElement("CG",mesh.ufl_cell(),1)
Q_cg = df.FunctionSpace(mesh,E_cg)

# DG0 Function Space
E_dg = df.FiniteElement("DG",mesh.ufl_cell(),0)
Q_dg = df.FunctionSpace(mesh,E_dg)

# Mixed element for coupled velocity-thickness solve
# (depth-averaged velocity, deformational velocity, DG0 thickness, CG1 thickness projection)
E_glac = df.MixedElement([E_cg,E_cg,E_dg])  
V_g = df.FunctionSpace(mesh,E_glac)

# Mixed element for coupled sediment stuff
# (Bedrock elevation, fluvial sediment flux, sediment thickness, effective subglacial cavity height
E_sed = df.MixedElement([E_dg,E_dg,E_dg,E_dg])
V_sed = df.FunctionSpace(mesh,E_sed)


# Mixed element for sediment diffusion (handled separately)
# (sediment thickness, sediment velocity)
E_dif = df.MixedElement([E_dg,E_dg])
V_dif = df.FunctionSpace(mesh,E_dif)

#########################################################
#################  FUNCTIONS  ###########################
#########################################################
np.random.seed(0)

# Velocity and thickness functions
U = df.Function(V_g)
dU = df.TrialFunction(V_g)
Phi = df.TestFunction(V_g)

# Split into components 
# depth-averaged velocity, deformation velocity, thickness
ubar,udef,H = df.split(U)
phibar,phidef,xsi = df.split(Phi)

ubar0 = df.Function(Q_cg)
udef0 = df.Function(Q_cg)
H0 = df.Function(Q_dg)

ubar0.dat.data[:] += 1e-10
udef0.dat.data[:] += 1e-10
H0.vector()[:] = 25

U.sub(0).assign(ubar0)
U.sub(1).assign(udef0)
U.sub(2).assign(H0)

# Sediment functions
T = df.Function(V_sed)
dT = df.TrialFunction(V_sed)
Psi = df.TestFunction(V_sed)

# Split into components
# Bed elevation, fluvial sed flux, sed thickness, water layer thickness
B,Qs,h_s,h_eff = df.split(T)
psi_B,psi_Q,psi_h,psi_eff = df.split(Psi)

B0 = df.Function(Q_dg)
Qs0 = df.Function(Q_dg)
h_s0 = df.Function(Q_dg)
h_eff0 = df.Function(Q_dg)

B0.interpolate(bed_expression)
h_s0.dat.data[:] = 1e-1
h_eff0.vector()[:] = 1.0

T.sub(0).assign(B0)
T.sub(2).assign(h_s0)
T.sub(3).assign(h_eff0)

# Sediment diffusion functions
P = df.Function(V_dif)
dP = df.TrialFunction(V_dif)
Tau = df.TestFunction(V_dif)

# Split into components
# sed thickness, sed velocity
h_sd,q_d = df.split(P)
w_d,tau_d = df.split(Tau)

h_sd0 = df.Function(Q_dg)

# Scalar test functions for uncoupled water flux
psi = df.TestFunction(Q_dg)
dQ = df.TrialFunction(Q_dg)

# Functions for computing the grounded indicator
grounded = df.Function(Q_dg)
grounded.vector()[:] = 1
dg = df.TrialFunction(Q_dg)

ghat = df.Function(Q_cg)
gl = df.Constant(0)

# Derived geometric quantities
Bhat = B + h_s                               # Top of sediment            

l = softplus(df.Constant(0),Bhat,alpha=5.0)  # Water surface, or the greater of
                                             # bedrock topography or zero

Base = softplus(Bhat,-rho/rho_w*H,alpha=5.0) # Ice base is the greater of the 
                                             # bedrock topography or the base of 
                                             # the shelf

D = softplus(-Bhat,df.Constant(0),alpha=5.0) # Water depth
S = Base + H                                 # Ice surface

# Basal traction
beta2 = df.interpolate(beta_expression,Q_cg)  #KT: beta_expression = 50

# Surface mass balance
climate_factor = df.Constant(1.0)      
#adot = climate_factor*(8 - 16/(4*L/3.)*x)  #this was hardcoded in new model
adot = climate_factor*(amax +(amin-amax)*(x/(2*L))) #USE THIS: Variable version of hardcoded from new model, produces same outcome but lets you easily change amin and amax

#adot = climate_factor*(amin + (amax-amin)/(1-df.exp(-c))*(1.-df.exp(-c*((S/2000)))))
# adot = climate_factor*(amin + (amax-amin)/(1-df.exp(-c))*(1.-df.exp(-c*((S/(zmax-zmin))))))*grounded + (-0.5*H)*(1-grounded) #OG paper code equation
#adot = climate_factor*(amin + (amax-amin)/(1-df.exp(-c))*(1.-df.exp(-c*((S/(zmax-zmin)))))) #changng 2000 to be max elev - min elev like in paper


########################################################
#################   MOMENTUM BALANCE   #################
########################################################

class VerticalBasis(object):
    def __init__(self,u,coef,dcoef):
        self.u = u              #KT interp: u is a list of velocity components
        self.coef = coef        #KT interp: coef function defines how much each velocity component contributes at specific depth (s)
        self.dcoef = dcoef      #KT interp: list of functions defining how du/ds changes with s

    def __call__(self,s):   #KT interp: sums ubar and udef weigted by their basis functions (coef)
        return sum([u*c(s) for u,c in zip(self.u,self.coef)])

    def ds(self,s):         #KT interp: depth derivative du/ds, computes vertical gradient of u(s) by using derivatives of basis functions (dcoef)
        return sum([u*c(s) for u,c in zip(self.u,self.dcoef)])

    def dx(self,s,x):       #KT interp: horizontal gradient du/dx, comutes horizontal gradient of u(s), allows for spatial variability
        return sum([u.dx(x)*c(s) for u,c in zip(self.u,self.coef)])

class VerticalIntegrator(object):
    def __init__(self,points,weights):
        self.points = points
        self.weights = weights
    def integral_term(self,f,s,w):
        return w*f(s)
    def intz(self,f):
        return sum([self.integral_term(f,s,w) for s,w in zip(self.points,self.weights)])

def dsdx(s):                        #KT interp: placeholder func for ds/dx
    return 0#1./H_*(S.dx(0) - s*H_.dx(0))

def dsdz(s):                        #KT interp: computes ds/dz = -1/H
    return -1./H

# ANSATZ    
p = 4.0
coef = [lambda s:1.0, lambda s:1./p*((p+1)*s**p-1.)]        #KT interp: defines velocity distribution over depth
    #KT: lambda s:1.0 = ubar contribution, basis function 1
    #KT: lambda s:1./p*((p+1)*s**p-1.) = variation due to deformation,vertical variation, basis function 2

dcoef = [lambda s:0.0, lambda s:(p+1)*s**(p-1)]             #KT interp: derivatives of basis functions
    #KT: lambda s:0.0 = derivative of basis function 1, no depth dependency for ubar
    #KT: lambda s:(p+1)*s**(p-1) = derivative of basis function 2, depth varitaion of deformation

# KT interp: lists that group related velocity & basis function components
u_ = [ubar,udef]        #KT interp: combines ubar and udef to represent full velocity profile u(s)        
u0_ = [ubar0,udef0]      #KT interp: u_ but initial conditions
phi_ = [phibar,phidef]       #KT interp: test functions

u = VerticalBasis(u_,coef,dcoef)
phi = VerticalBasis(phi_,coef,dcoef)

def eta_v(s):       #KT interp: computes effective viscosity at depth based on vel gradient?
    return b/2.*((u.dx(s,0) + u.ds(s)*dsdx(s))**2 \
                +0.25*((u.ds(s)*dsdz(s))**2) \
                + eps_reg)**((1.-n)/(2*n))

def membrane_xx(s):     #KT interp: computes longitudinal stress components using vel. and viscosity?
    return (phi.dx(s,0) + phi.ds(s)*dsdx(s))*H*eta_v(s)*(4*(u.dx(s,0) + u.ds(s)*dsdx(s)))

def shear_xz(s):        #KT interp: computes shear stress components using vertical vel. gradients?
    return dsdz(s)**2*phi.ds(s)*H*eta_v(s)*u.ds(s)

points,weights = full_quad(4) 
vi = VerticalIntegrator(points,weights)

# Pressure and sliding law
P_0 = H                                               # Overburden pressure
P_w = ufl.max_value(k*H,rho_w/rho_i*(l-Base))         # Water pressure
N = ufl.max_value(P_0-P_w,df.Constant(0.000))         # Effective pressure

# Nonstandard driving stress term
driving_stress = -df.Dx(rho*g*H*phibar,0)*S*df.dx + df.jump(rho*g*H*phibar,nhat)*df.avg(S)*df.dS + rho*g*H*phibar*nhat*S*df.ds

# Momentum balance weak form
I_stress = (- vi.intz(membrane_xx) - vi.intz(shear_xz) - phi(1)*beta2*u(1)*N)*df.dx - driving_stress

#############################################################################
##########################  MASS BALANCE  ###################################
#############################################################################

# Jumps and averages for DG0 method
H_avg = 0.5*(H('+') + H('-'))       #KT interp: average of ice thickness on either side of interface
H_jump = H('+')*nhat('+') + H('-')*nhat('-')        #KT interp: difference in flux terms for H across interface
xsi_avg = 0.5*(xsi('+') + xsi('-'))
xsi_jump = xsi('+')*nhat('+') + xsi('-')*nhat('-')

uvec = df.as_vector([ubar,])        #KT interp: constructs velocity vector from ubar
unorm = (df.dot(uvec,uvec))**0.5            #KT interp: scalar vel magnitude
uH = df.avg(ubar)*H_avg + 0.5*df.avg(unorm)*H_jump      #KT interp: trasport term for ice thickness

# Flotation indicator               
floating = df.conditional(
                df.lt(H, rho_w/rho_i*(0 - Bhat)),
                df.Constant(1.0),df.Constant(0.0))


I_transport = ((H-H0)/dt - adot + scf*H*floating)*xsi*df.dx + df.dot(uH,xsi_jump)*df.dS + ubar*H*nhat*xsi*df.ds(2)

# Weak form of coupled velocity/thickness solve
R = I_stress + I_transport

#############################################################################
###########################  Water Flux  ####################################
#############################################################################

# Meltrate
me = (beta2*N*u(1)**2/(rho*La) - Min(adot,-1e-16))*sigmoid(H-(thklim+df.Constant(1)))

#h = df.CellDiameter(mesh)

dQ_avg = 0.5*(dQ('+') + dQ('-'))
dQ_jump = dQ('+')*nhat('+') + dQ('-')*nhat('-')
psi_avg = 0.5*(psi('+') + psi('-'))
psi_jump = psi('+')*nhat('+') + psi('-')*nhat('-')

dQ_upwind = dQ_avg + 0.5*dQ_jump

Qw = df.Function(Q_dg)
R_Qw = -me*psi*df.dx + df.dot(dQ_upwind,psi_jump)*df.dS + dQ*nhat*psi*df.ds(2)
A_Qw = df.lhs(R_Qw)
b_Qw = df.rhs(R_Qw)


#############################################################################
#############################  Sediment evolution  ##########################
#############################################################################

delta = df.exp(-h_s/l_s) # mantling effect where presence of sediment thk will yield no bed erosion 
ubar_w = Qw/h_eff        # Water velocity

Bdot = -be*beta2*N*u(1)**2*delta     # Rate of bedrock erosion
edot = cc/h_eff*ubar_w**2*(1-delta)  # Erosion rate
ddot = d*Qs/Qw                       # Deposition rate

Qs_avg = 0.5*(Qs('+') + Qs('-'))
Qs_jump = Qs('+')*nhat('+') + Qs('-')*nhat('-')
psiQ_avg = 0.5*(psi_Q('+') + psi_Q('-'))
psiQ_jump = psi_Q('+')*nhat('+') + psi_Q('-')*nhat('-')

Qs_upwind = Qs_avg + 0.5*Qs_jump

h = df.CellDiameter(mesh)

R_Qs = (ddot - edot)*psi_Q*df.dx + df.dot(Qs_upwind,psiQ_jump)*df.dS        #KT interp: sediment flux?
R_hs = psi_h*((h_s - h_s0)/dt + rho_r/rho_s*Bdot - ddot + edot)*df.dx       #KT interp: sediment thickness changes?
R_B = psi_B*((B-B0)/dt - Bdot)*df.dx                                           #KT interp: changes in bedrock elevation
R_heff = psi_eff*(h_eff - softplus(h_0,Base-Bhat,alpha=5.0))*df.dx          #KT interp: effective layer thickness?

# Weak form of sediment dynamics, solves for bedrock elevation, fluvial sed. flux,
# sediment thickness, projected sediment thickness, and effective water layer thickness.
R_sed = R_B + R_Qs + R_hs + R_heff
J_sed = df.derivative(R_sed,T,dT)


#############################################################################
###########################  Sediment diffusion  ############################
#############################################################################

f = df.Constant(1) - df.exp(-h_sd/h_ref)
hd_avg = 0.5*(h_sd('+') + h_sd('-'))
hd_jump = h_sd('+')*nhat('+') + h_sd('-')*nhat('-')

qvec = df.as_vector([q_d,])
qnorm = (df.dot(qvec,qvec) + 1e-10)**0.5
qH = df.avg(q_d)*hd_avg + 0.5*df.avg(qnorm)*hd_jump

R_dh = w_d*(h_sd - h_sd0)/dt*df.dx + df.jump(w_d,nhat)*qH*df.dS# + w_d*nhat*q_d*df.ds
R_dq = tau_d*q_d*df.dx - k_diff*df.Dx(tau_d*f,0)*(h_sd + B)*df.dx + df.jump(tau_d*f,nhat)*k_diff*df.avg(h_sd + B)*df.dS + tau_d*nhat*k_diff*f*(h_sd + B)*df.ds 

R_d = R_dh + R_dq

##############################################################################
##########################  Solvers  #########################################
##############################################################################

solver_parameters_mass ={"snes_type": 'vinewtonrsls',
                        "pc_factor_mat_solver_type": "mumps",
                        "snes_rtol": 1.e-4,
                        "snes_atol": 1.e-3,  
                     	"snes_max_it": 10,
                    	"report": True,
                        "snes_monitor": None,
                     	"error_on_nonconvergence": True}

mass_problem = df.NonlinearVariationalProblem(R, U)

lower_bounds = df.Function(V_g)
upper_bounds = df.Function(V_g)
lower_bounds.sub(0).assign(df.Constant(-1e10))
lower_bounds.sub(1).assign(df.Constant(-1e10))
lower_bounds.sub(2).assign(thklim)

upper_bounds.sub(0).assign(df.Constant(1e10))
upper_bounds.sub(1).assign(df.Constant(1e10))
upper_bounds.sub(2).assign(1e10)

mass_solver = df.NonlinearVariationalSolver(mass_problem, solver_parameters=solver_parameters_mass)

solver_parameters_sed ={"snes_type": 'vinewtonrsls',
                        "pc_factor_mat_solver_type": "mumps",
                        "snes_rtol": 1.e-4,
                        "snes_atol": 1.e-3,  
                     	"snes_max_it": 10,
                    	"report": True,
                        "snes_monitor": None,
                     	"error_on_nonconvergence": True}

sed_problem = df.NonlinearVariationalProblem(R_sed, T)

lower_bounds_sed = df.Function(V_sed)
upper_bounds_sed = df.Function(V_sed)
lower_bounds_sed.sub(0).assign(df.Constant(-1e10))
lower_bounds_sed.sub(1).assign(df.Constant(-1e10))
lower_bounds_sed.sub(2).assign(-1e10)
lower_bounds_sed.sub(3).assign(-1e10)

upper_bounds_sed.sub(0).assign(df.Constant(1e10))
upper_bounds_sed.sub(1).assign(df.Constant(1e10))
upper_bounds_sed.sub(2).assign(1e10)
upper_bounds_sed.sub(3).assign(1e10)

sed_solver = df.NonlinearVariationalSolver(sed_problem, solver_parameters=solver_parameters_sed)

###############################################################################
#########################  KT:Initialize velocities  ##########################
###############################################################################
# from old model, random perturbations in velocity
ubar0 = df.Function(Q_cg)
udef0 = df.Function(Q_cg)
ubar0_array = ubar0.vector().get_local()
udef0_array = udef0.vector().get_local()
ubar0_array += 1e-1 * np.random.randn(len(ubar0_array)) + 100.0
udef0_array += 1e-3 * np.random.randn(len(udef0_array))
ubar0.vector().set_local(ubar0_array)
udef0.vector().set_local(udef0_array)
ubar0.vector().apply("insert")
udef0.vector().apply("insert") 
###############################################################################
#########################  Animation Init.  ###################################
###############################################################################
t_end = 20000

# #KT: Plots for saving only 
# plt.ioff()
# fig, ax = plt.subplots(nrows=6,sharex=True,figsize=(10,12))
# # fig_v, ax_v = plt.subplots(figsize=(10, 12))
# fig_disp,ax_disp = plt.subplots(nrows = 2, sharex = False) #comment out to display
# plt.close(fig_disp)
# plt.close(fig)
# # plt.close(fig_v)


# #KT: one plot displayed, uncomment out to display
# # plt.ion()
# # fig_disp,ax_disp = plt.subplots(nrows = 2, sharex = False)
# # plt.show()

# #KT: Plotting Glacier Profile & SMB - display
# xx = df.interpolate(x,Q_dg).dat.data[:]
# ph_bed1, = ax_disp[0].plot(xx,B0.dat.data[:],'k-')
# base1 = df.interpolate(Base,Q_dg)
# ph_base1, = ax_disp[0].plot(xx,base1.dat.data[:],'b-')
# surf1 = df.interpolate(S,Q_dg)
# ph_surf1, = ax_disp[0].plot(xx,surf1.dat.data[:],'c-')
# sed1 = df.interpolate(B0 + h_s0,Q_dg)
# ph_sed1, = ax_disp[0].plot(xx,sed1.dat.data[:],'g-')
# ax_disp[0].plot(xx,np.zeros_like(xx),'b:',lw=0.5)
# ax_disp[0].set_ylabel('Elevation (m)')
# ax_disp[0].legend(loc = 'center right', fontsize = 10)

# SMB = df.interpolate(adot,Q_dg)
# x_smb = SMB.dat.data[:]
# y_smb = surf1.dat.data[:]
# ph_SMB_disp, = ax_disp[1].plot(x_smb, y_smb , 'b-')
# ax_disp[1].axvline(x = 0, color='gray', linestyle='--')
# #ela_line = ax_smb.axhline(y= 0,color = "pink", linestyle ="--")
# ax_disp[1].invert_xaxis()
# ax_disp[1].set_ylabel("Glacier Surface (m)")
# ax_disp[1].set_xlabel("SMB (m/yr)")


# #Plotting Glacier Profile - animation
# xx = df.interpolate(x,Q_dg).dat.data[:]
# ph_bed, = ax[0].plot(xx,B0.dat.data[:],'k-')
# base = df.interpolate(Base,Q_dg)
# ph_base, = ax[0].plot(xx,base.dat.data[:],'b-')
# surf = df.interpolate(S,Q_dg)
# ph_surf, = ax[0].plot(xx,surf.dat.data[:],'c-')
# sed = df.interpolate(B0 + h_s0,Q_dg)
# ph_sed, = ax[0].plot(xx,sed.dat.data[:],'g-')
# ax[0].plot(xx,np.zeros_like(xx),'b:',lw=0.5)
# ax[0].set_ylabel('Elevation (m)')
# ax[0].legend(loc = 'center right', fontsize = 10)

# #KT: Grounding Line Plot
# ph_grounded, = ax[1].plot(xx, np.zeros_like(xx), 'k-')
# ax[1].set_ylim(-0.05, 1.05)
# ax[1].set_ylabel('Grounded(0) VS Floating(1)')
# ax[1].yaxis.tick_right()
# ax[1].yaxis.set_label_position("right")


# thk = np.zeros(300)

# #KT: Ice Thickness Plot
# thick = df.interpolate(H0,Q_dg)
# ph_thick, = ax[2].plot(xx,np.zeros_like(xx), 'b-')
# ax[2].set_ylim(0,500)
# ax[2].set_ylabel('Ice Thickness (m)')

# #KT: Velocity vs Distance Plot
# ph_us, = ax[3].plot(xx,np.zeros_like(xx),'r-',lw=1.5, label = 'Surface Velocity')
# ph_ub, = ax[3].plot(xx,np.zeros_like(xx),'g:',lw=1.5, label = 'Basal Velocity')
# ax[3].set_ylim(0,500)
# ax[3].set_ylabel('Speed (m/yr)')

# #Kt: Sediment Thickness Plot
# hs = df.interpolate(h_s0, Q_dg)
# ph_hs, = ax[4].plot(xx,np.zeros_like(xx),'k-',lw=1.0)
# ax[4].set_ylabel('Sediment Thickness (m)')
# ax[4].legend(loc = 'center right', fontsize = 10)
# ax[4].yaxis.tick_right()
# ax[4].yaxis.set_label_position("right")

# #KT: Fluvial Sediment Flux Plot
# fluv = df.interpolate(Qs0,Q_dg)
# ph_fluv, = ax[5].plot(xx,np.zeros_like(xx),'b')
# ax[5].set_ylabel('Fluvial Sediment Flux')
# ax[5].set_ylim(0,500)
# ax[5].set_xlabel('Distance (m)')

# #KT: Velocity over time plot initialization
# ph_surface, = ax_v.plot([], [], 'r-', label="Surface Velocity (max)")
# ph_basal, = ax_v.plot([], [], 'g:', label="Basal Velocity (max)")
# ax_v.set_xlim(0, 10000)  
# ax_v.set_ylim(0, 100)    
# ax_v.set_xlabel("Time (years)")
# ax_v.set_ylabel("Velocity (m/yr)")
# ax_v.set_title("Velocity Evolution Over Time")
# ax_v.legend(loc = 'center right', fontsize = 10)


#KT: SMB Plot
# SMB = df.interpolate(adot,Q_dg)
# x_smb = SMB.dat.data[:]
# y_smb = surf.dat.data[:]
# # ELA = np.interp(0, SMB.dat.data[:], surf.dat.data[:])
# ph_SMB, = ax_smb.plot(x_smb, y_smb , 'b-')
# ax_smb.axvline(x = 0, color='gray', linestyle='--')
# #ela_line = ax_smb.axhline(y= 0,color = "pink", linestyle ="--")
# ax_smb.invert_xaxis()
# ax_smb.set_ylabel("Glacier Surface (m)")
# ax_smb.set_xlabel("SMB (m/yr)")

#KT: Storing values over time 
time_values = []  
surface_velocity = []  
basal_velocity = []

#KT: Initializing Dictionaries - Keys = timesteps, Values = arrays of size 300 containing mesh values
time_dict = {}      # Dictionary to store step count and associated timestep
counter_dict ={}
bed_dict = {}       # Dictionary of bed geometry (for animation)
base_dict = {}      # Dictionary of base geometry (for animation)
surf_dict = {}      # Dictionary of surface geometry (for animation)
sed_dict = {}       # Dictionary of sediment geometry (for animation)
H_dict = {}         # Dictionary of ice thicknesses
us_dict = {}        # Dictionary of surface velocities
ub_dict = {}        # Dictionary of basal velocities
Hs_dict = {}        # Dictionary of sediment thickness
GL_dict = {}        # Dictionary of grounding line location
Qs_dict = {}        # Dictionary of fluvial sediment flux
SMB_dict = {}       # Dictionary for SMB
DATA_dict ={}

#KT: Grabbing timestamp at start of simulation, should match with simulation run time
start_time = datetime.now().strftime("%Y_%m_%d__%H_%M_%S")

#KT: Function to update animation frames to be compiled into simulation movie
# frames = []
# def update_anim(frame):
#     "updates the plots for FuncAnimation"
#     t = time_dict[frame]
#     time_text1.set_text(f'Time: {t:.2f} years')

#     ph_bed.set_ydata(bed_dict[t])
#     ph_base.set_ydata(base_dict[t])
#     ph_surf.set_ydata(surf_dict[t])
#     ph_sed.set_ydata(sed_dict[t])

#     ph_grounded.set_ydata(GL_dict[t])
#     ph_us.set_ydata(us_dict[t])
#     ph_ub.set_ydata(ub_dict[t])
#     ax[3].set_ylim(0, max(us_dict[t]) + 100)

#     ph_thick.set_ydata(H_dict[t])
#     ax[2].set_ylim(0, max(H_dict[t]) + 100)
#     ph_hs.set_ydata(Hs_dict[t])
#     ax[4].set_ylim(0, max(Hs_dict[t]) + 100)
#     ph_fluv.set_ydata(Qs_dict[t])
#     ax[5].set_ylim(0, max(Qs_dict[t]) + 100)

#     for a in ax:
#         a.relim()  
#         a.autoscale_view(True, True, True) 

#     fig.canvas.draw()
#     fig.canvas.flush_events()

#     return [time_text1, ph_bed, ph_base, ph_surf, ph_sed, ph_grounded, ph_ub, ph_us, ph_thick, ph_hs, ph_fluv]


######### KT: OUTPUT DIRECTORIES & FILES FOR STORING SIMULATION DATA ################################

# ANIMATION SIMULATION subfolders based on how simulation ends
anim_crash = "/home/kayatroyer/Repositories/brinkmodeltest/Output/Simulation_Animations/Crashes"
anim_rupt = "/home/kayatroyer/Repositories/brinkmodeltest/Output/Simulation_Animations/Interrupts"
full_anim = "/home/kayatroyer/Repositories/brinkmodeltest/Output/Simulation_Animations/SuccessfulRuns"
vel_path = "/home/kayatroyer/Repositories/brinkmodeltest/Output/Velocity Plots"

success_filename = os.path.join(full_anim,f"FullModelRun_{start_time}.mp4")
crash_filename = os.path.join(anim_crash,f"CrashedModelRun_{start_time}.mp4")
interrupt_filename = os.path.join(anim_rupt,f"InterruptedModelRun_{start_time}.mp4")

vel_file = os.path.join(vel_path, f"VelocityPlot_{start_time}.jpg")

#KT: comment out if you not saving at end and just using for display 
display_path = "/home/kayatroyer/Repositories/brinkmodeltest/Output/diplay_plots"
display_file = os.path.join(display_path,f"displayplots_{start_time}.jpg")
display_file_init =os.path.join(display_path,f"init_displayplots_{start_time}.jpg")

#KT: Dictionary Folder
dicts_folder = "/home/kayatroyer/Repositories/brinkmodeltest/Output/Variable_Dictionaries"
dict_filename = os.path.join(dicts_folder, f"DATA_Dictionary_{start_time}.pkl.gz")

#KT: State Variable Folder 
state_folder = "/home/kayatroyer/Repositories/brinkmodeltest/Output/State_Variables" 

#KT: Making output directories and files
indiv_run_name = f"Run_{start_time}"
indiv_run_path = os.path.join(state_folder,indiv_run_name)
os.makedirs(indiv_run_path, exist_ok=True)

#KT: initializing checkpoint files in appropriate directories
half_checkpoint_path = os.path.join(indiv_run_path, "checkpoint_halfway.h5")
final_checkpoint_path = os.path.join(indiv_run_path, "checkpoint_final.h5")

# KT: loading data int pickle
# def load_existing_data():
#     with gzip.open(dict_filename, 'wt',compresslevel=3) as f:
#         json.dump(DATA_dict,f)
#     except (FileNotFoundError, EOFError):       #I dont really want this
#         return {}
#         print("STOP! PICKLE LOADING ISNT WORKING")
    
#KT: In event of interrupt, simulation movie saves
# def interrupt(signal, frame):
#     print("Interrupt signal received. Saving animation before shutdown...")
#     # fig_v.savefig(vel_file)
#     ani_rupt = animation.FuncAnimation(fig, update_anim, frames = len(frames), interval=100, blit=False)
#     ani_rupt.save(interrupt_filename, writer="ffmpeg", fps=10, dpi=150)  # Save the crashed animation
#     print(f"Interrupted, Animation saved to: {interrupt}")
#     print("MODEL INTERRUPTED, NOT SAVING FINAL STATE VARIABLES")
#     sys.exit(0)
# signal.signal(signal.SIGTERM, interrupt)  # Catches `kill` command
# signal.signal(signal.SIGINT, interrupt)   # Catches `Ctrl+C`

##############################################################################
############################  Run Model  #####################################
##############################################################################
#KT: Time counter display for model run
# time_text1 = ax[0].text(0.70,0.90,'', transform=ax[0].transAxes, fontsize = 12)
# time_text2 = ax_disp[0].text(0.70,0.90,'', fontsize = 12)
# # time_text3 = ax_smb.text(0.70,0.90,'', fontsize = 12)
# time_text4 = ax_v.text(0.70,0.90,'', fontsize = 12)

#KT: stores time values every 10 time steps
#velocity_interval = 10  # Update every 10 timesteps

# Time interval
t = 0.0
t_end = 20000

counter = 0

# Maximum time step!!  Increase with caution.
dt_max = 5.0   #OG time step


# LOOP OVER TIME: START OF MODEL SIMULATION
while t<t_end:
    try: # If the solvers don't converge, reduce the time step and try again.
        print(t,dt_float)
        
        # if counter%1==0:
        #     fig.canvas.start_event_loop(0.00001)
        #     fig.canvas.draw_idle()
            
        # Solve the velocity-ice thickness equations
        mass_solver.solve(bounds=(lower_bounds,upper_bounds))

        # Solve for water flux
        df.solve(A_Qw == b_Qw,Qw)

        # Solve the sediment equations (excluding diffusion)
        sed_solver.solve(bounds=(lower_bounds_sed,upper_bounds_sed))

        # Update the previous thickness
        ubar0.dat.data[:] = U.dat.data[0]
        udef0.dat.data[:] = U.dat.data[1]
        H0.dat.data[:] = U.dat.data[2]

        # Update previous bed elevation
        B0.dat.data[:] = T.dat.data[0]

        # Update previous sediment thickness, KT added updating fluvial sed flux
        h_s0.dat.data[:] = T.dat.data[2]
        Qs0.dat.data[:] = T.dat.data[1]

        # diffusion mechanics
        # Set current sed thickness to solution from sed transport
        h_sd0.dat.data[:] = h_s0.dat.data[:]
        P.sub(0).assign(h_s0)

        # Solve diffusion equation
        df.solve(R_d==0,P)

        # Update main sed thickness variables
        h_s0.dat.data[:] = P.dat.data[0]
        T.sub(2).assign(h_s0)

        # Increase time step if solvers complete successfully
        dt_float = min(1.05*dt_float,dt_max)
        dt.assign(dt_float)

        ############ PERFORM PLOTTING ######################


        #KT: Time text for plots
        # time_text1.set_text(f'Time: {t:.2f} years') 
        # time_text2.set_text(f'Time: {t:.2f} years') 
        # time_text4.set_text(f'Time: {t:.2f} years') 


        nan_idx = np.where(np.isnan(time_values))[0]  #this adds times to the time_values as it runs through the loop and replaces nans
        if len(nan_idx) > 0:  
            time_values[nan_idx[0]] = t      


        #KT: Grounding Line 
        grounded = df.interpolate(floating,Q_dg)
        g_ = grounded.dat.data[:]
        # ph_grounded.set_ydata(g_)     #plotting

        #KT: Surface & Basal Velocity Plot
        us_ = df.project(u(0), Q_dg).vector().get_local()
        ub_ = df.project(u(1), Q_dg).vector().get_local()

        thk = H0.vector().get_local()
        us_[thk<=(thklim+1e-2)] = np.nan
        ub_[thk<=(thklim+1e-2)] = np.nan
    
        #Updating Data on Mesh
        base = df.interpolate(Base,Q_dg)
        surf = df.interpolate(S,Q_dg)
        sed = df.interpolate(B0 + h_s0,Q_dg) 
        hs = df.interpolate(h_s0,Q_dg)
        Qs = df.interpolate(Qs0, Q_dg)
        thick = df.interpolate(H0,Q_dg)
        SMB = df.interpolate(adot,Q_dg)

        #Updating Data on Main Glacier Plot - animation
        # ph_bed.set_ydata(B0.dat.data[:])
        # ph_base.set_ydata(base.dat.data[:])
        # ph_surf.set_ydata(surf.dat.data[:])
        # ph_sed.set_ydata(sed.dat.data[:])

        #Updating Data on Main Glacier Plot - display
        # ph_bed1.set_ydata(B0.dat.data[:])
        # ph_base1.set_ydata(base.dat.data[:])
        # ph_surf1.set_ydata(surf.dat.data[:])
        # ph_sed1.set_ydata(sed.dat.data[:])

        #Updating basal and surface speeds vs distance
        # ph_us.set_ydata(us_)
        # ph_ub.set_ydata(ub_)

        #KT: Updating Ice Thickness
        # ph_thick.set_ydata(thick.dat.data[:])
        # ax[2].set_ylim(0,thick.dat.data[:].max()+100)  #KT: actively changing y axis

        #KT: added to avoid issues with NaNs in the thklim 
        us_filtered = us_[np.isfinite(us_)]  
        # if len(us_filtered) > 0:
        #     ax[3].set_ylim(0, us_filtered.max() + 100) #KT: actively changing y axis

        #KT: Updating Sediment Thickness
        # ph_hs.set_ydata(hs.dat.data[:])
        # ax[4].set_ylim(0,hs.dat.data[:].max() + 100) #KT: actively changing y axis

        #KT: Updating Fluvial Seidment Flux
        # ph_fluv.set_ydata(Qs.dat.data[:])
        # ax[5].set_ylim(0,Qs.dat.data[:].max() + 100 ) #KT: actively changing y axis

        #KT: Updating SMB Plot
        # ph_SMB.set_ydata(surf.dat.data[:])
        # ph_SMB_disp.set_ydata(surf.dat.data[:])

        #KT: Velocities and GL over time, velocity extracted from 50 indices behind terminus
        notNAN = np.where(np.isfinite(us_))[0]

        if len(notNAN) > 0:
            terminus = notNAN[-1]
        else:
            terminus = None

        if terminus is not None and terminus >= 50:
            term_usvel = us_[terminus - 50]  
            term_ubvel = ub_[terminus - 50]
        else:
            term_usvel = 0
            term_ubvel = 0

        if np.isnan(term_usvel):
            term_usvel = 0
        if np.isnan(term_ubvel):
            term_ubvel = 0

        time_values.append(t)
        surface_velocity.append(term_usvel)  
        basal_velocity.append(term_ubvel)


        # if counter % 10 == 0:
        #     ph_surface.set_xdata(time_values)
        #     ph_basal.set_xdata(time_values)
        #     ph_surface.set_ydata(surface_velocity)
        #     ph_basal.set_ydata(basal_velocity)

        # ax_v.set_xlim(0,10000)      

        # if t > ax_v.get_xlim()[1]:
        # #     ax_v.set_xlim(0, t + 100)  

        # if max(surface_velocity + basal_velocity) > ax_v.get_ylim()[1]:
        #     ax_v.set_ylim(0, max(surface_velocity + basal_velocity) + 100)  # Extend velocity axis


        # Redraw the figure
        # if counter % 100 == 0:
        #     fig_disp.canvas.draw()

        ##################### DONE PLOTTING, START STORING VARIABLES #####################

        # if counter == 0:
        #     fig_disp.savefig(display_file_init) 

        #KT: Update animation frames
        # frames.append(counter)

        #KT: Load Dictionaries with values 
        time_dict[counter] = t
        counter_dict[t] = counter 

        # if counter % 2 == 0:
        bed_dict[t] = B0.dat.data[:].copy()
        base_dict[t] = base.dat.data[:]
        surf_dict[t] = surf.dat.data[:]
        sed_dict[t] = sed.dat.data[:]
        H_dict[t] = thick.dat.data[:]         
        us_dict[t] = us_           
        ub_dict[t] = ub_        
        Hs_dict[t] = hs.dat.data[:]        
        GL_dict[t] = g_             
        Qs_dict[t] = Qs.dat.data[:]    
        SMB_dict[t] = SMB.dat.data[:].copy()
    

        #KT: Loading main data dictionary with dictionaries
        if counter % 1000 == 0:
            DATA_dict.update({
                'counter_dict': counter_dict,
                'bed_dict': bed_dict,
                'base_dict': base_dict,
                'surf_dict': surf_dict,
                'sed_dict': sed_dict,
                'H_dict': H_dict,
                'us_dict': us_dict,
                'ub_dict': ub_dict,
                'Hs_dict': Hs_dict,
                'GL_dict': GL_dict,
                'Qs_dict': Qs_dict,
                'SMB_dict': SMB_dict
            })

         #KT: Pickling Data Dictionary
        if counter % 2000 == 0:
            if os.path.exists(dict_filename):
                with gzip.open(dict_filename, 'rb', compresslevel=3) as f:
                    existing_data = pickle.load(f)
            else:
                existing_data = {}
            
            existing_data.update(DATA_dict)

            with gzip.open(dict_filename, 'wb', compresslevel=3) as f:
                pickle.dump(existing_data, f)
            
            DATA_dict.clear()
        
        #KT: Storing to HDF5 file 
        # half = t_end//2

        
        # if counter == half:
        #     with open(os.path.join(indiv_run_path, 'time_dict.json'), 'w') as f:
        #         json.dump(time_dict, f)

        #     # Saving Functions
        #     with CheckpointFile(half_checkpoint_path, "w") as Check_Half:
        #         Check_Half.save_function(U, name = 'U_State')
        #         Check_Half.save_function(T, name = 'T_State')
        #         Check_Half.save_function(P, name = 'P_State')
        #         Check_Half.save_mesh(mesh)      

        t+=dt_float
        counter+=1

    except df.ConvergenceError:

        # If the solvers don't converge, reset variables to previous time step's succesful values and try again.  
        U.sub(0).assign(1e-10)
        U.sub(1).assign(1e-10)
        U.sub(2).assign(H0)

        T.sub(0).assign(B0)
        T.sub(1).assign(df.Constant(0.0))
        T.sub(2).assign(h_s0)
        T.sub(3).assign(h_eff0)

        dt_float/=2.
        dt.assign(dt_float)
        print('convergence failed, reducing time step and trying again')

#KT: adding these in case of intterupt 
    # except KeyboardInterrupt:
    #     interrupt(signal.SIGINT, None)
    #     break
    # except Exception as e:
    #     print(f"Unexpected Error: {e}")
    #     interrupt(signal.SIGINT, None)
    #     break

    if (dt_float < 1e-10): # Things have really gone off the rails and the simulation is shutting down
        print("model stalling, time step approaching zero...")
        
        # fig_v.savefig(vel_file)
        # fig_disp.savefig(display_file)


        # ani_break = animation.FuncAnimation(fig, update_anim, frames = len(frames), interval=100, blit=False) #KT: added
        # ani_break.save(crash_filename, writer="ffmpeg", fps=10, dpi=150)    #KT: added

        # print(f"Crashed Animation saved to: {crash_filename}")  #KT: added
        # print("MODEL BREAKING NOT SAVING FINAL STATE VARIABLES")
        break

#KT: added this to do a final save of model stuff
if t >= t_end-5:
    # ani = animation.FuncAnimation(fig, update_anim, frames = len(frames), interval=100, blit=False)
    # #if not ani._is_saving:  # Ensure animation isn't already being written
    # ani.save(success_filename, writer="ffmpeg", fps=10, dpi=150)

    # print(f"Successful Model Run Animation saved to: {success_filename}")

    # print("Simulation completed successfully. Saving final state variables... ")

    # with open(os.path.join(indiv_run_path, 'time_dict_final.json'), 'w') as f:
    #             json.dump(time_dict, f)
        
    # with CheckpointFile(final_checkpoint_path, "w") as Check_Final:
    #     Check_Final.save_function(U, name = 'U_State_final')
    #     Check_Final.save_function(T, name = 'T_State_final')
    #     Check_Final.save_function(P, name = 'P_State_final')
    #     Check_Final.save_mesh(mesh)

    # # fig_v.savefig(vel_file)
    # fig_disp.savefig(display_file)

    print("Last save of dictionary")
    time_dict[counter] = t
    counter_dict[t] = counter 

    bed_dict[t] = B0.dat.data[:].copy()
    base_dict[t] = base.dat.data[:]
    surf_dict[t] = surf.dat.data[:]
    sed_dict[t] = sed.dat.data[:]
    H_dict[t] = thick.dat.data[:]         
    us_dict[t] = us_           
    ub_dict[t] = ub_        
    Hs_dict[t] = hs.dat.data[:]        
    GL_dict[t] = g_             
    Qs_dict[t] = Qs.dat.data[:]     
    SMB_dict[t] = SMB.dat.data[:].copy()


    DATA_dict.update({
        'counter_dict': counter_dict,
        'bed_dict': bed_dict,
        'base_dict': base_dict,
        'surf_dict': surf_dict,
        'sed_dict': sed_dict,
        'H_dict': H_dict,
        'us_dict': us_dict,
        'ub_dict': ub_dict,
        'Hs_dict': Hs_dict,
        'GL_dict': GL_dict,
        'Qs_dict': Qs_dict,
        'SMB_dict': SMB_dict
    })

    if os.path.exists(dict_filename):
        with gzip.open(dict_filename, 'rb', compresslevel=3) as f:
            existing_data = pickle.load(f)
            
        existing_data.update(DATA_dict)

        with gzip.open(dict_filename, 'wb', compresslevel=3) as f:
            pickle.dump(existing_data, f)
            
    DATA_dict.clear()

    print("ALL SAVING DONE!")
